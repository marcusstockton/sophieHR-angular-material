//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const BASE_URL = new InjectionToken<string>('BASE_URL');

export interface IAccountClient {
    getToken(userLogins: UserLogins): Observable<UserTokens>;
    registerNewAdminUser(userData: RegisterUserDto): Observable<UserTokens>;
    getList(): Observable<EmployeeListDto[]>;
    getListOfManagers(): Observable<string[]>;
    getListOfCompanyAdmins(): Observable<string[]>;
}

@Injectable()
export class AccountClient implements IAccountClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7189";
    }

    getToken(userLogins: UserLogins): Observable<UserTokens> {
        let url_ = this.baseUrl + "/api/Account";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userLogins);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserTokens>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserTokens>;
        }));
    }

    protected processGetToken(response: HttpResponseBase): Observable<UserTokens> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserTokens.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    registerNewAdminUser(userData: RegisterUserDto): Observable<UserTokens> {
        let url_ = this.baseUrl + "/api/Account/RegisterNewAdminUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterNewAdminUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterNewAdminUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserTokens>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserTokens>;
        }));
    }

    protected processRegisterNewAdminUser(response: HttpResponseBase): Observable<UserTokens> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserTokens.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getList(): Observable<EmployeeListDto[]> {
        let url_ = this.baseUrl + "/api/Account/GetListOfUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeeListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeeListDto[]>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<EmployeeListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmployeeListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getListOfManagers(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Account/GetListOfManagers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListOfManagers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListOfManagers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetListOfManagers(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getListOfCompanyAdmins(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Account/GetListOfCompanyAdmin";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListOfCompanyAdmins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListOfCompanyAdmins(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetListOfCompanyAdmins(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICompaniesClient {
    getCompanies(): Observable<CompanyDetailNoLogo[]>;
    postCompany(companyDto: CompanyCreateDto): Observable<CompanyDetailDto>;
    getCompanyNames(): Observable<KeyValuePairOfGuidAndString[]>;
    getCompany(id: string): Observable<CompanyDetailDto>;
    putCompany(id: string, companyDetail: CompanyDetailNoLogo): Observable<FileResponse>;
    deleteCompany(id: string): Observable<FileResponse>;
    uploadLogo(id: string, logo: FileParameter | null | undefined): Observable<FileResponse>;
    getAutoSuggestion(search: string | null | undefined): Observable<string[]>;
    getMapFromLatLong(lat: number | undefined, lon: number | undefined, zoomLevel: number | undefined, mapType: number | undefined, width: number | undefined, viewType: number | undefined): Observable<string>;
    postcodeAutoComplete(postcode: string | null | undefined): Observable<string[]>;
    postcodeLookup(postcode: string | null | undefined): Observable<PostcodeLookup>;
}

@Injectable()
export class CompaniesClient implements ICompaniesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7189";
    }

    getCompanies(): Observable<CompanyDetailNoLogo[]> {
        let url_ = this.baseUrl + "/api/Companies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompanies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyDetailNoLogo[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyDetailNoLogo[]>;
        }));
    }

    protected processGetCompanies(response: HttpResponseBase): Observable<CompanyDetailNoLogo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CompanyDetailNoLogo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postCompany(companyDto: CompanyCreateDto): Observable<CompanyDetailDto> {
        let url_ = this.baseUrl + "/api/Companies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(companyDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyDetailDto>;
        }));
    }

    protected processPostCompany(response: HttpResponseBase): Observable<CompanyDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CompanyDetailDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCompanyNames(): Observable<KeyValuePairOfGuidAndString[]> {
        let url_ = this.baseUrl + "/api/Companies/GetCompanyNamesForSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompanyNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanyNames(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<KeyValuePairOfGuidAndString[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<KeyValuePairOfGuidAndString[]>;
        }));
    }

    protected processGetCompanyNames(response: HttpResponseBase): Observable<KeyValuePairOfGuidAndString[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(KeyValuePairOfGuidAndString.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCompany(id: string): Observable<CompanyDetailDto> {
        let url_ = this.baseUrl + "/api/Companies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyDetailDto>;
        }));
    }

    protected processGetCompany(response: HttpResponseBase): Observable<CompanyDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    putCompany(id: string, companyDetail: CompanyDetailNoLogo): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Companies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(companyDetail);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processPutCompany(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteCompany(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Companies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteCompany(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadLogo(id: string, logo: FileParameter | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Companies/{id}/upload-logo";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (logo !== null && logo !== undefined)
            content_.append("logo", logo.data, logo.fileName ? logo.fileName : "logo");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadLogo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUploadLogo(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAutoSuggestion(search: string | null | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Companies/get-location-autosuggestion?";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAutoSuggestion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAutoSuggestion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetAutoSuggestion(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getMapFromLatLong(lat: number | undefined, lon: number | undefined, zoomLevel: number | undefined, mapType: number | undefined, width: number | undefined, viewType: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Companies/GetMapFromLatLong?";
        if (lat === null)
            throw new Error("The parameter 'lat' cannot be null.");
        else if (lat !== undefined)
            url_ += "lat=" + encodeURIComponent("" + lat) + "&";
        if (lon === null)
            throw new Error("The parameter 'lon' cannot be null.");
        else if (lon !== undefined)
            url_ += "lon=" + encodeURIComponent("" + lon) + "&";
        if (zoomLevel === null)
            throw new Error("The parameter 'zoomLevel' cannot be null.");
        else if (zoomLevel !== undefined)
            url_ += "zoomLevel=" + encodeURIComponent("" + zoomLevel) + "&";
        if (mapType === null)
            throw new Error("The parameter 'mapType' cannot be null.");
        else if (mapType !== undefined)
            url_ += "mapType=" + encodeURIComponent("" + mapType) + "&";
        if (width === null)
            throw new Error("The parameter 'width' cannot be null.");
        else if (width !== undefined)
            url_ += "width=" + encodeURIComponent("" + width) + "&";
        if (viewType === null)
            throw new Error("The parameter 'viewType' cannot be null.");
        else if (viewType !== undefined)
            url_ += "viewType=" + encodeURIComponent("" + viewType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMapFromLatLong(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMapFromLatLong(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetMapFromLatLong(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postcodeAutoComplete(postcode: string | null | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Companies/postcode-auto-complete?";
        if (postcode !== undefined && postcode !== null)
            url_ += "postcode=" + encodeURIComponent("" + postcode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostcodeAutoComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostcodeAutoComplete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processPostcodeAutoComplete(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postcodeLookup(postcode: string | null | undefined): Observable<PostcodeLookup> {
        let url_ = this.baseUrl + "/api/Companies/postcode-lookup?";
        if (postcode !== undefined && postcode !== null)
            url_ += "postcode=" + encodeURIComponent("" + postcode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostcodeLookup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostcodeLookup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostcodeLookup>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostcodeLookup>;
        }));
    }

    protected processPostcodeLookup(response: HttpResponseBase): Observable<PostcodeLookup> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostcodeLookup.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IDepartmentsClient {
    getDepartmentsByCompanyId(companyId: string): Observable<DepartmentDetailDto[]>;
    getDepartment(id: string): Observable<DepartmentDetailDto>;
    putDepartment(id: string, departmentDetail: DepartmentDetailDto): Observable<void>;
    deleteDepartment(id: string): Observable<void>;
    postDepartment(departmentCreateDto: DepartmentCreateDto): Observable<DepartmentDetailDto>;
}

@Injectable()
export class DepartmentsClient implements IDepartmentsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7189";
    }

    getDepartmentsByCompanyId(companyId: string): Observable<DepartmentDetailDto[]> {
        let url_ = this.baseUrl + "/api/Departments/get-departments-by-companyid/{companyId}";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined.");
        url_ = url_.replace("{companyId}", encodeURIComponent("" + companyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartmentsByCompanyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartmentsByCompanyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepartmentDetailDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepartmentDetailDto[]>;
        }));
    }

    protected processGetDepartmentsByCompanyId(response: HttpResponseBase): Observable<DepartmentDetailDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DepartmentDetailDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDepartment(id: string): Observable<DepartmentDetailDto> {
        let url_ = this.baseUrl + "/api/Departments/get-department-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepartmentDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepartmentDetailDto>;
        }));
    }

    protected processGetDepartment(response: HttpResponseBase): Observable<DepartmentDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DepartmentDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    putDepartment(id: string, departmentDetail: DepartmentDetailDto): Observable<void> {
        let url_ = this.baseUrl + "/api/Departments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(departmentDetail);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutDepartment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPutDepartment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteDepartment(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Departments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDepartment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteDepartment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postDepartment(departmentCreateDto: DepartmentCreateDto): Observable<DepartmentDetailDto> {
        let url_ = this.baseUrl + "/api/Departments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(departmentCreateDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostDepartment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostDepartment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepartmentDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepartmentDetailDto>;
        }));
    }

    protected processPostDepartment(response: HttpResponseBase): Observable<DepartmentDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = DepartmentDetailDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IEmployeesClient {
    getEmployeesForCompanyId(companyId: string): Observable<EmployeeListDto[]>;
    getManagersForCompanyId(companyId: string): Observable<EmployeeListDto[]>;
    getEmployeesForManager(managerId: string): Observable<EmployeeListDto[]>;
    getEmployee(id: string): Observable<EmployeeDetailDto>;
    uploadAvatar(id: string, contentType: string | null | undefined, contentDisposition: string | null | undefined, headers: any[] | null | undefined, length: number | undefined, name: string | null | undefined, fileName: string | null | undefined): Observable<EmployeeAvatar>;
    putEmployee(id: string, employeeDetail: EmployeeDetailDto): Observable<EmployeeDetailDto>;
    deleteEmployee(id: string): Observable<void>;
    createEmployee(role: string | null | undefined, employeeDto: EmployeeCreateDto): Observable<EmployeeDetailDto>;
    getTitles(): Observable<string[]>;
    jobTitleAutoComplete(jobTitle: string | null | undefined): Observable<string[]>;
}

@Injectable()
export class EmployeesClient implements IEmployeesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7189";
    }

    getEmployeesForCompanyId(companyId: string): Observable<EmployeeListDto[]> {
        let url_ = this.baseUrl + "/api/Employees/get-by-company/{companyId}";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined.");
        url_ = url_.replace("{companyId}", encodeURIComponent("" + companyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeesForCompanyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeesForCompanyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeeListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeeListDto[]>;
        }));
    }

    protected processGetEmployeesForCompanyId(response: HttpResponseBase): Observable<EmployeeListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmployeeListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getManagersForCompanyId(companyId: string): Observable<EmployeeListDto[]> {
        let url_ = this.baseUrl + "/api/Employees/list-of-managers-for-company/{companyId}";
        if (companyId === undefined || companyId === null)
            throw new Error("The parameter 'companyId' must be defined.");
        url_ = url_.replace("{companyId}", encodeURIComponent("" + companyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManagersForCompanyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManagersForCompanyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeeListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeeListDto[]>;
        }));
    }

    protected processGetManagersForCompanyId(response: HttpResponseBase): Observable<EmployeeListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmployeeListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getEmployeesForManager(managerId: string): Observable<EmployeeListDto[]> {
        let url_ = this.baseUrl + "/api/Employees/list-of-employees-for-manager/{managerId}";
        if (managerId === undefined || managerId === null)
            throw new Error("The parameter 'managerId' must be defined.");
        url_ = url_.replace("{managerId}", encodeURIComponent("" + managerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeesForManager(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeesForManager(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeeListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeeListDto[]>;
        }));
    }

    protected processGetEmployeesForManager(response: HttpResponseBase): Observable<EmployeeListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmployeeListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getEmployee(id: string): Observable<EmployeeDetailDto> {
        let url_ = this.baseUrl + "/api/Employees/get-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeeDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeeDetailDto>;
        }));
    }

    protected processGetEmployee(response: HttpResponseBase): Observable<EmployeeDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadAvatar(id: string, contentType: string | null | undefined, contentDisposition: string | null | undefined, headers: any[] | null | undefined, length: number | undefined, name: string | null | undefined, fileName: string | null | undefined): Observable<EmployeeAvatar> {
        let url_ = this.baseUrl + "/api/Employees/{id}/upload-avatar";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType !== null && contentType !== undefined)
            content_.append("ContentType", contentType.toString());
        if (contentDisposition !== null && contentDisposition !== undefined)
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers !== null && headers !== undefined)
            headers.forEach(item_ => content_.append("Headers", item_.toString()));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (fileName !== null && fileName !== undefined)
            content_.append("FileName", fileName.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadAvatar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadAvatar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeeAvatar>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeeAvatar>;
        }));
    }

    protected processUploadAvatar(response: HttpResponseBase): Observable<EmployeeAvatar> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeAvatar.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    putEmployee(id: string, employeeDetail: EmployeeDetailDto): Observable<EmployeeDetailDto> {
        let url_ = this.baseUrl + "/api/Employees/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(employeeDetail);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeeDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeeDetailDto>;
        }));
    }

    protected processPutEmployee(response: HttpResponseBase): Observable<EmployeeDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteEmployee(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Employees/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteEmployee(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createEmployee(role: string | null | undefined, employeeDto: EmployeeCreateDto): Observable<EmployeeDetailDto> {
        let url_ = this.baseUrl + "/api/Employees/create-employee?";
        if (role !== undefined && role !== null)
            url_ += "role=" + encodeURIComponent("" + role) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(employeeDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeeDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeeDetailDto>;
        }));
    }

    protected processCreateEmployee(response: HttpResponseBase): Observable<EmployeeDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = EmployeeDetailDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTitles(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Employees/GetTitles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTitles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTitles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetTitles(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    jobTitleAutoComplete(jobTitle: string | null | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/Employees/job-title-autocomplete?";
        if (jobTitle !== undefined && jobTitle !== null)
            url_ += "jobTitle=" + encodeURIComponent("" + jobTitle) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processJobTitleAutoComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processJobTitleAutoComplete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processJobTitleAutoComplete(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ILeaveRequestsClient {
    getLeaveTypes(): Observable<{ [key: string]: string; }>;
    getLeaveRequestsForEmployee(employeeId: string): Observable<LeaveRequest[]>;
    getLeaveRequest(id: string): Observable<LeaveRequest>;
    putLeaveRequest(id: string, leaveRequest: LeaveRequest): Observable<void>;
    deleteLeaveRequest(id: string): Observable<void>;
    postLeaveRequest(leaveRequestDto: CreateLeaveRequest): Observable<LeaveRequest>;
}

@Injectable()
export class LeaveRequestsClient implements ILeaveRequestsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7189";
    }

    getLeaveTypes(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/LeaveRequests/GetLeaveTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processGetLeaveTypes(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getLeaveRequestsForEmployee(employeeId: string): Observable<LeaveRequest[]> {
        let url_ = this.baseUrl + "/api/LeaveRequests/GetLeaveRequestsForEmployee/{employeeId}";
        if (employeeId === undefined || employeeId === null)
            throw new Error("The parameter 'employeeId' must be defined.");
        url_ = url_.replace("{employeeId}", encodeURIComponent("" + employeeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveRequestsForEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveRequestsForEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LeaveRequest[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LeaveRequest[]>;
        }));
    }

    protected processGetLeaveRequestsForEmployee(response: HttpResponseBase): Observable<LeaveRequest[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LeaveRequest.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getLeaveRequest(id: string): Observable<LeaveRequest> {
        let url_ = this.baseUrl + "/api/LeaveRequests/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaveRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaveRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LeaveRequest>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LeaveRequest>;
        }));
    }

    protected processGetLeaveRequest(response: HttpResponseBase): Observable<LeaveRequest> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveRequest.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    putLeaveRequest(id: string, leaveRequest: LeaveRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/LeaveRequests/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(leaveRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutLeaveRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutLeaveRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPutLeaveRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteLeaveRequest(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/LeaveRequests/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLeaveRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLeaveRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteLeaveRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postLeaveRequest(leaveRequestDto: CreateLeaveRequest): Observable<LeaveRequest> {
        let url_ = this.baseUrl + "/api/LeaveRequests";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(leaveRequestDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostLeaveRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostLeaveRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LeaveRequest>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LeaveRequest>;
        }));
    }

    protected processPostLeaveRequest(response: HttpResponseBase): Observable<LeaveRequest> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaveRequest.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface INotesClient {
    getNotesForEmployee(employeeId: string): Observable<NoteDetailDto[]>;
    getNote(id: string): Observable<NoteDetailDto>;
    putNotes(id: string, noteDto: NoteDetailDto): Observable<void>;
    deleteNotes(id: string): Observable<FileResponse>;
    postNotes(employeeId: string, noteInput: NoteCreateDto): Observable<NoteDetailDto>;
    getNoteTypes(): Observable<{ [key: string]: string; }>;
}

@Injectable()
export class NotesClient implements INotesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:7189";
    }

    getNotesForEmployee(employeeId: string): Observable<NoteDetailDto[]> {
        let url_ = this.baseUrl + "/api/Notes/get-notes-for-employee/{employeeId}";
        if (employeeId === undefined || employeeId === null)
            throw new Error("The parameter 'employeeId' must be defined.");
        url_ = url_.replace("{employeeId}", encodeURIComponent("" + employeeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotesForEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotesForEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoteDetailDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoteDetailDto[]>;
        }));
    }

    protected processGetNotesForEmployee(response: HttpResponseBase): Observable<NoteDetailDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NoteDetailDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getNote(id: string): Observable<NoteDetailDto> {
        let url_ = this.baseUrl + "/api/Notes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNote(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNote(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoteDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoteDetailDto>;
        }));
    }

    protected processGetNote(response: HttpResponseBase): Observable<NoteDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoteDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    putNotes(id: string, noteDto: NoteDetailDto): Observable<void> {
        let url_ = this.baseUrl + "/api/Notes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(noteDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutNotes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutNotes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPutNotes(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteNotes(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Notes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNotes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNotes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteNotes(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postNotes(employeeId: string, noteInput: NoteCreateDto): Observable<NoteDetailDto> {
        let url_ = this.baseUrl + "/api/Notes/{employeeId}";
        if (employeeId === undefined || employeeId === null)
            throw new Error("The parameter 'employeeId' must be defined.");
        url_ = url_.replace("{employeeId}", encodeURIComponent("" + employeeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(noteInput);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostNotes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostNotes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NoteDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NoteDetailDto>;
        }));
    }

    protected processPostNotes(response: HttpResponseBase): Observable<NoteDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoteDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getNoteTypes(): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/Notes/GetNoteTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNoteTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNoteTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processGetNoteTypes(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class UserTokens implements IUserTokens {
    token?: string | undefined;
    userName?: string | undefined;
    expiryTime?: string;
    refreshToken?: string | undefined;
    id?: string;
    email?: string | undefined;
    expiredTime?: Date;
    role?: string | undefined;
    departmentId?: string | undefined;
    companyId?: string | undefined;

    constructor(data?: IUserTokens) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.userName = _data["userName"];
            this.expiryTime = _data["expiryTime"];
            this.refreshToken = _data["refreshToken"];
            this.id = _data["id"];
            this.email = _data["email"];
            this.expiredTime = _data["expiredTime"] ? new Date(_data["expiredTime"].toString()) : <any>undefined;
            this.role = _data["role"];
            this.departmentId = _data["departmentId"];
            this.companyId = _data["companyId"];
        }
    }

    static fromJS(data: any): UserTokens {
        data = typeof data === 'object' ? data : {};
        let result = new UserTokens();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["userName"] = this.userName;
        data["expiryTime"] = this.expiryTime;
        data["refreshToken"] = this.refreshToken;
        data["id"] = this.id;
        data["email"] = this.email;
        data["expiredTime"] = this.expiredTime ? this.expiredTime.toISOString() : <any>undefined;
        data["role"] = this.role;
        data["departmentId"] = this.departmentId;
        data["companyId"] = this.companyId;
        return data;
    }
}

export interface IUserTokens {
    token?: string | undefined;
    userName?: string | undefined;
    expiryTime?: string;
    refreshToken?: string | undefined;
    id?: string;
    email?: string | undefined;
    expiredTime?: Date;
    role?: string | undefined;
    departmentId?: string | undefined;
    companyId?: string | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class UserLogins implements IUserLogins {
    userName!: string;
    password!: string;

    constructor(data?: IUserLogins) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): UserLogins {
        data = typeof data === 'object' ? data : {};
        let result = new UserLogins();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data;
    }
}

export interface IUserLogins {
    userName: string;
    password: string;
}

export class RegisterUserDto implements IRegisterUserDto {
    firstName?: string | undefined;
    lastName?: string | undefined;
    emailAddress!: string;
    password!: string;

    constructor(data?: IRegisterUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): RegisterUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        return data;
    }
}

export interface IRegisterUserDto {
    firstName?: string | undefined;
    lastName?: string | undefined;
    emailAddress: string;
    password: string;
}

export class EmployeeListDto implements IEmployeeListDto {
    id?: string;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    jobTitle?: string | undefined;
    workEmailAddress?: string | undefined;
    personalEmailAddress?: string | undefined;
    workPhoneNumber?: string | undefined;
    workMobileNumber?: string | undefined;
    personalMobileNumber?: string | undefined;
    holidayAllowance?: number;
    dateOfBirth?: Date;
    startOfEmployment?: Date;
    address?: EmployeeAddress | undefined;
    departmentId?: string;
    companyId?: string;
    department?: DepartmentIdNameDto | undefined;
    company?: CompanyIdNameDto | undefined;

    constructor(data?: IEmployeeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.jobTitle = _data["jobTitle"];
            this.workEmailAddress = _data["workEmailAddress"];
            this.personalEmailAddress = _data["personalEmailAddress"];
            this.workPhoneNumber = _data["workPhoneNumber"];
            this.workMobileNumber = _data["workMobileNumber"];
            this.personalMobileNumber = _data["personalMobileNumber"];
            this.holidayAllowance = _data["holidayAllowance"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.startOfEmployment = _data["startOfEmployment"] ? new Date(_data["startOfEmployment"].toString()) : <any>undefined;
            this.address = _data["address"] ? EmployeeAddress.fromJS(_data["address"]) : <any>undefined;
            this.departmentId = _data["departmentId"];
            this.companyId = _data["companyId"];
            this.department = _data["department"] ? DepartmentIdNameDto.fromJS(_data["department"]) : <any>undefined;
            this.company = _data["company"] ? CompanyIdNameDto.fromJS(_data["company"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EmployeeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["jobTitle"] = this.jobTitle;
        data["workEmailAddress"] = this.workEmailAddress;
        data["personalEmailAddress"] = this.personalEmailAddress;
        data["workPhoneNumber"] = this.workPhoneNumber;
        data["workMobileNumber"] = this.workMobileNumber;
        data["personalMobileNumber"] = this.personalMobileNumber;
        data["holidayAllowance"] = this.holidayAllowance;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["startOfEmployment"] = this.startOfEmployment ? this.startOfEmployment.toISOString() : <any>undefined;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["departmentId"] = this.departmentId;
        data["companyId"] = this.companyId;
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEmployeeListDto {
    id?: string;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    jobTitle?: string | undefined;
    workEmailAddress?: string | undefined;
    personalEmailAddress?: string | undefined;
    workPhoneNumber?: string | undefined;
    workMobileNumber?: string | undefined;
    personalMobileNumber?: string | undefined;
    holidayAllowance?: number;
    dateOfBirth?: Date;
    startOfEmployment?: Date;
    address?: EmployeeAddress | undefined;
    departmentId?: string;
    companyId?: string;
    department?: DepartmentIdNameDto | undefined;
    company?: CompanyIdNameDto | undefined;
}

export abstract class Base implements IBase {
    id?: string;
    createdDate?: Date;
    updatedDate?: Date;

    constructor(data?: IBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Base {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Base' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IBase {
    id?: string;
    createdDate?: Date;
    updatedDate?: Date;
}

export abstract class Address extends Base implements IAddress {
    line1?: string | undefined;
    line2?: string | undefined;
    line3?: string | undefined;
    line4?: string | undefined;
    postcode?: string | undefined;
    county?: string | undefined;
    lat?: number;
    lon?: number;
    addressType?: AddressType;

    constructor(data?: IAddress) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.line1 = _data["line1"];
            this.line2 = _data["line2"];
            this.line3 = _data["line3"];
            this.line4 = _data["line4"];
            this.postcode = _data["postcode"];
            this.county = _data["county"];
            this.lat = _data["lat"];
            this.lon = _data["lon"];
            this.addressType = _data["addressType"];
        }
    }

    static override fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Address' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["line3"] = this.line3;
        data["line4"] = this.line4;
        data["postcode"] = this.postcode;
        data["county"] = this.county;
        data["lat"] = this.lat;
        data["lon"] = this.lon;
        data["addressType"] = this.addressType;
        super.toJSON(data);
        return data;
    }
}

export interface IAddress extends IBase {
    line1?: string | undefined;
    line2?: string | undefined;
    line3?: string | undefined;
    line4?: string | undefined;
    postcode?: string | undefined;
    county?: string | undefined;
    lat?: number;
    lon?: number;
    addressType?: AddressType;
}

export class EmployeeAddress extends Address implements IEmployeeAddress {

    constructor(data?: IEmployeeAddress) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): EmployeeAddress {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeAddress();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IEmployeeAddress extends IAddress {
}

export enum AddressType {
    Company = 0,
    Employee = 1,
}

export class DepartmentIdNameDto implements IDepartmentIdNameDto {
    id?: string;
    name?: string | undefined;

    constructor(data?: IDepartmentIdNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DepartmentIdNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentIdNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IDepartmentIdNameDto {
    id?: string;
    name?: string | undefined;
}

export class CompanyIdNameDto implements ICompanyIdNameDto {
    id?: string;
    name?: string | undefined;

    constructor(data?: ICompanyIdNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CompanyIdNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyIdNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ICompanyIdNameDto {
    id?: string;
    name?: string | undefined;
}

export class CompanyDetailNoLogo implements ICompanyDetailNoLogo {
    id?: string;
    createdDate?: Date;
    updatedDate?: Date;
    name?: string | undefined;
    address?: AddressBasic | undefined;

    constructor(data?: ICompanyDetailNoLogo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.address = _data["address"] ? AddressBasic.fromJS(_data["address"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CompanyDetailNoLogo {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyDetailNoLogo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICompanyDetailNoLogo {
    id?: string;
    createdDate?: Date;
    updatedDate?: Date;
    name?: string | undefined;
    address?: AddressBasic | undefined;
}

export class AddressBasic implements IAddressBasic {
    line1?: string | undefined;
    line2?: string | undefined;
    line3?: string | undefined;
    line4?: string | undefined;
    postcode?: string | undefined;
    county?: string | undefined;

    constructor(data?: IAddressBasic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.line1 = _data["line1"];
            this.line2 = _data["line2"];
            this.line3 = _data["line3"];
            this.line4 = _data["line4"];
            this.postcode = _data["postcode"];
            this.county = _data["county"];
        }
    }

    static fromJS(data: any): AddressBasic {
        data = typeof data === 'object' ? data : {};
        let result = new AddressBasic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["line3"] = this.line3;
        data["line4"] = this.line4;
        data["postcode"] = this.postcode;
        data["county"] = this.county;
        return data;
    }
}

export interface IAddressBasic {
    line1?: string | undefined;
    line2?: string | undefined;
    line3?: string | undefined;
    line4?: string | undefined;
    postcode?: string | undefined;
    county?: string | undefined;
}

export class KeyValuePairOfGuidAndString implements IKeyValuePairOfGuidAndString {
    key?: string;
    value?: string | undefined;

    constructor(data?: IKeyValuePairOfGuidAndString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): KeyValuePairOfGuidAndString {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValuePairOfGuidAndString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IKeyValuePairOfGuidAndString {
    key?: string;
    value?: string | undefined;
}

export class CompanyDetailDto implements ICompanyDetailDto {
    id?: string;
    createdDate?: Date;
    updatedDate?: Date;
    name?: string | undefined;
    logo?: string | undefined;
    employeeCount?: number;
    address?: CompanyAddress | undefined;

    constructor(data?: ICompanyDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.logo = _data["logo"];
            this.employeeCount = _data["employeeCount"];
            this.address = _data["address"] ? CompanyAddress.fromJS(_data["address"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CompanyDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["logo"] = this.logo;
        data["employeeCount"] = this.employeeCount;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICompanyDetailDto {
    id?: string;
    createdDate?: Date;
    updatedDate?: Date;
    name?: string | undefined;
    logo?: string | undefined;
    employeeCount?: number;
    address?: CompanyAddress | undefined;
}

export class CompanyAddress extends Address implements ICompanyAddress {
    mapImage?: string | undefined;

    constructor(data?: ICompanyAddress) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.mapImage = _data["mapImage"];
        }
    }

    static override fromJS(data: any): CompanyAddress {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyAddress();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mapImage"] = this.mapImage;
        super.toJSON(data);
        return data;
    }
}

export interface ICompanyAddress extends IAddress {
    mapImage?: string | undefined;
}

export class CompanyCreateDto implements ICompanyCreateDto {
    name?: string | undefined;
    address?: AddressCreateDto | undefined;

    constructor(data?: ICompanyCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.address = _data["address"] ? AddressCreateDto.fromJS(_data["address"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CompanyCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICompanyCreateDto {
    name?: string | undefined;
    address?: AddressCreateDto | undefined;
}

export class AddressCreateDto implements IAddressCreateDto {
    line1?: string | undefined;
    line2?: string | undefined;
    line3?: string | undefined;
    line4?: string | undefined;
    postcode?: string | undefined;
    county?: string | undefined;
    mapImage?: string | undefined;

    constructor(data?: IAddressCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.line1 = _data["line1"];
            this.line2 = _data["line2"];
            this.line3 = _data["line3"];
            this.line4 = _data["line4"];
            this.postcode = _data["postcode"];
            this.county = _data["county"];
            this.mapImage = _data["mapImage"];
        }
    }

    static fromJS(data: any): AddressCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["line3"] = this.line3;
        data["line4"] = this.line4;
        data["postcode"] = this.postcode;
        data["county"] = this.county;
        data["mapImage"] = this.mapImage;
        return data;
    }
}

export interface IAddressCreateDto {
    line1?: string | undefined;
    line2?: string | undefined;
    line3?: string | undefined;
    line4?: string | undefined;
    postcode?: string | undefined;
    county?: string | undefined;
    mapImage?: string | undefined;
}

export class PostcodeLookup implements IPostcodeLookup {
    status?: number;
    result?: Result | undefined;

    constructor(data?: IPostcodeLookup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.result = _data["result"] ? Result.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PostcodeLookup {
        data = typeof data === 'object' ? data : {};
        let result = new PostcodeLookup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPostcodeLookup {
    status?: number;
    result?: Result | undefined;
}

export class Result implements IResult {
    postcode?: string | undefined;
    quality?: number;
    eastings?: number;
    northings?: number;
    country?: string | undefined;
    nhs_ha?: string | undefined;
    longitude?: number;
    latitude?: number;
    european_electoral_region?: string | undefined;
    primary_care_trust?: string | undefined;
    region?: string | undefined;
    lsoa?: string | undefined;
    msoa?: string | undefined;
    incode?: string | undefined;
    outcode?: string | undefined;
    parliamentary_constituency?: string | undefined;
    admin_district?: string | undefined;
    parish?: string | undefined;
    admin_county?: string | undefined;
    admin_ward?: string | undefined;
    ced?: string | undefined;
    ccg?: string | undefined;
    nuts?: string | undefined;
    codes?: Codes | undefined;

    constructor(data?: IResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.postcode = _data["postcode"];
            this.quality = _data["quality"];
            this.eastings = _data["eastings"];
            this.northings = _data["northings"];
            this.country = _data["country"];
            this.nhs_ha = _data["nhs_ha"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.european_electoral_region = _data["european_electoral_region"];
            this.primary_care_trust = _data["primary_care_trust"];
            this.region = _data["region"];
            this.lsoa = _data["lsoa"];
            this.msoa = _data["msoa"];
            this.incode = _data["incode"];
            this.outcode = _data["outcode"];
            this.parliamentary_constituency = _data["parliamentary_constituency"];
            this.admin_district = _data["admin_district"];
            this.parish = _data["parish"];
            this.admin_county = _data["admin_county"];
            this.admin_ward = _data["admin_ward"];
            this.ced = _data["ced"];
            this.ccg = _data["ccg"];
            this.nuts = _data["nuts"];
            this.codes = _data["codes"] ? Codes.fromJS(_data["codes"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Result {
        data = typeof data === 'object' ? data : {};
        let result = new Result();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["postcode"] = this.postcode;
        data["quality"] = this.quality;
        data["eastings"] = this.eastings;
        data["northings"] = this.northings;
        data["country"] = this.country;
        data["nhs_ha"] = this.nhs_ha;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["european_electoral_region"] = this.european_electoral_region;
        data["primary_care_trust"] = this.primary_care_trust;
        data["region"] = this.region;
        data["lsoa"] = this.lsoa;
        data["msoa"] = this.msoa;
        data["incode"] = this.incode;
        data["outcode"] = this.outcode;
        data["parliamentary_constituency"] = this.parliamentary_constituency;
        data["admin_district"] = this.admin_district;
        data["parish"] = this.parish;
        data["admin_county"] = this.admin_county;
        data["admin_ward"] = this.admin_ward;
        data["ced"] = this.ced;
        data["ccg"] = this.ccg;
        data["nuts"] = this.nuts;
        data["codes"] = this.codes ? this.codes.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResult {
    postcode?: string | undefined;
    quality?: number;
    eastings?: number;
    northings?: number;
    country?: string | undefined;
    nhs_ha?: string | undefined;
    longitude?: number;
    latitude?: number;
    european_electoral_region?: string | undefined;
    primary_care_trust?: string | undefined;
    region?: string | undefined;
    lsoa?: string | undefined;
    msoa?: string | undefined;
    incode?: string | undefined;
    outcode?: string | undefined;
    parliamentary_constituency?: string | undefined;
    admin_district?: string | undefined;
    parish?: string | undefined;
    admin_county?: string | undefined;
    admin_ward?: string | undefined;
    ced?: string | undefined;
    ccg?: string | undefined;
    nuts?: string | undefined;
    codes?: Codes | undefined;
}

export class Codes implements ICodes {
    admin_district?: string | undefined;
    admin_county?: string | undefined;
    admin_ward?: string | undefined;
    parish?: string | undefined;
    parliamentary_constituency?: string | undefined;
    ccg?: string | undefined;
    ccg_id?: string | undefined;
    ced?: string | undefined;
    nuts?: string | undefined;
    lsoa?: string | undefined;
    msoa?: string | undefined;
    lau2?: string | undefined;

    constructor(data?: ICodes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.admin_district = _data["admin_district"];
            this.admin_county = _data["admin_county"];
            this.admin_ward = _data["admin_ward"];
            this.parish = _data["parish"];
            this.parliamentary_constituency = _data["parliamentary_constituency"];
            this.ccg = _data["ccg"];
            this.ccg_id = _data["ccg_id"];
            this.ced = _data["ced"];
            this.nuts = _data["nuts"];
            this.lsoa = _data["lsoa"];
            this.msoa = _data["msoa"];
            this.lau2 = _data["lau2"];
        }
    }

    static fromJS(data: any): Codes {
        data = typeof data === 'object' ? data : {};
        let result = new Codes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["admin_district"] = this.admin_district;
        data["admin_county"] = this.admin_county;
        data["admin_ward"] = this.admin_ward;
        data["parish"] = this.parish;
        data["parliamentary_constituency"] = this.parliamentary_constituency;
        data["ccg"] = this.ccg;
        data["ccg_id"] = this.ccg_id;
        data["ced"] = this.ced;
        data["nuts"] = this.nuts;
        data["lsoa"] = this.lsoa;
        data["msoa"] = this.msoa;
        data["lau2"] = this.lau2;
        return data;
    }
}

export interface ICodes {
    admin_district?: string | undefined;
    admin_county?: string | undefined;
    admin_ward?: string | undefined;
    parish?: string | undefined;
    parliamentary_constituency?: string | undefined;
    ccg?: string | undefined;
    ccg_id?: string | undefined;
    ced?: string | undefined;
    nuts?: string | undefined;
    lsoa?: string | undefined;
    msoa?: string | undefined;
    lau2?: string | undefined;
}

export class DepartmentDetailDto implements IDepartmentDetailDto {
    id?: string;
    createdDate?: Date;
    updatedDate?: Date;
    name?: string | undefined;
    companyId?: string;

    constructor(data?: IDepartmentDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.companyId = _data["companyId"];
        }
    }

    static fromJS(data: any): DepartmentDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["companyId"] = this.companyId;
        return data;
    }
}

export interface IDepartmentDetailDto {
    id?: string;
    createdDate?: Date;
    updatedDate?: Date;
    name?: string | undefined;
    companyId?: string;
}

export class DepartmentCreateDto implements IDepartmentCreateDto {
    name?: string | undefined;
    companyId?: string;

    constructor(data?: IDepartmentCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.companyId = _data["companyId"];
        }
    }

    static fromJS(data: any): DepartmentCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["companyId"] = this.companyId;
        return data;
    }
}

export interface IDepartmentCreateDto {
    name?: string | undefined;
    companyId?: string;
}

export class EmployeeDetailDto implements IEmployeeDetailDto {
    id?: string;
    title?: string | undefined;
    gender?: string | undefined;
    userName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    workEmailAddress?: string | undefined;
    personalEmailAddress?: string | undefined;
    workPhoneNumber?: string | undefined;
    workMobileNumber?: string | undefined;
    personalMobileNumber?: string | undefined;
    phoneNumber?: string | undefined;
    holidayAllowance?: number;
    jobTitle?: string | undefined;
    dateOfBirth?: Date;
    startOfEmployment?: Date;
    endOfEmployment?: Date | undefined;
    passportNumber?: string | undefined;
    nationalInsuranceNumber?: string | undefined;
    addressId?: string | undefined;
    managerId?: string | undefined;
    companyId?: string | undefined;
    departmentId?: string | undefined;
    employeeAvatarId?: string | undefined;
    avatar?: EmployeeAvatarDetail | undefined;
    department?: DepartmentIdNameDto | undefined;
    company?: CompanyIdNameDto | undefined;
    address?: EmployeeAddress | undefined;

    constructor(data?: IEmployeeDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.gender = _data["gender"];
            this.userName = _data["userName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.workEmailAddress = _data["workEmailAddress"];
            this.personalEmailAddress = _data["personalEmailAddress"];
            this.workPhoneNumber = _data["workPhoneNumber"];
            this.workMobileNumber = _data["workMobileNumber"];
            this.personalMobileNumber = _data["personalMobileNumber"];
            this.phoneNumber = _data["phoneNumber"];
            this.holidayAllowance = _data["holidayAllowance"];
            this.jobTitle = _data["jobTitle"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.startOfEmployment = _data["startOfEmployment"] ? new Date(_data["startOfEmployment"].toString()) : <any>undefined;
            this.endOfEmployment = _data["endOfEmployment"] ? new Date(_data["endOfEmployment"].toString()) : <any>undefined;
            this.passportNumber = _data["passportNumber"];
            this.nationalInsuranceNumber = _data["nationalInsuranceNumber"];
            this.addressId = _data["addressId"];
            this.managerId = _data["managerId"];
            this.companyId = _data["companyId"];
            this.departmentId = _data["departmentId"];
            this.employeeAvatarId = _data["employeeAvatarId"];
            this.avatar = _data["avatar"] ? EmployeeAvatarDetail.fromJS(_data["avatar"]) : <any>undefined;
            this.department = _data["department"] ? DepartmentIdNameDto.fromJS(_data["department"]) : <any>undefined;
            this.company = _data["company"] ? CompanyIdNameDto.fromJS(_data["company"]) : <any>undefined;
            this.address = _data["address"] ? EmployeeAddress.fromJS(_data["address"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EmployeeDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["gender"] = this.gender;
        data["userName"] = this.userName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["workEmailAddress"] = this.workEmailAddress;
        data["personalEmailAddress"] = this.personalEmailAddress;
        data["workPhoneNumber"] = this.workPhoneNumber;
        data["workMobileNumber"] = this.workMobileNumber;
        data["personalMobileNumber"] = this.personalMobileNumber;
        data["phoneNumber"] = this.phoneNumber;
        data["holidayAllowance"] = this.holidayAllowance;
        data["jobTitle"] = this.jobTitle;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["startOfEmployment"] = this.startOfEmployment ? this.startOfEmployment.toISOString() : <any>undefined;
        data["endOfEmployment"] = this.endOfEmployment ? this.endOfEmployment.toISOString() : <any>undefined;
        data["passportNumber"] = this.passportNumber;
        data["nationalInsuranceNumber"] = this.nationalInsuranceNumber;
        data["addressId"] = this.addressId;
        data["managerId"] = this.managerId;
        data["companyId"] = this.companyId;
        data["departmentId"] = this.departmentId;
        data["employeeAvatarId"] = this.employeeAvatarId;
        data["avatar"] = this.avatar ? this.avatar.toJSON() : <any>undefined;
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEmployeeDetailDto {
    id?: string;
    title?: string | undefined;
    gender?: string | undefined;
    userName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    workEmailAddress?: string | undefined;
    personalEmailAddress?: string | undefined;
    workPhoneNumber?: string | undefined;
    workMobileNumber?: string | undefined;
    personalMobileNumber?: string | undefined;
    phoneNumber?: string | undefined;
    holidayAllowance?: number;
    jobTitle?: string | undefined;
    dateOfBirth?: Date;
    startOfEmployment?: Date;
    endOfEmployment?: Date | undefined;
    passportNumber?: string | undefined;
    nationalInsuranceNumber?: string | undefined;
    addressId?: string | undefined;
    managerId?: string | undefined;
    companyId?: string | undefined;
    departmentId?: string | undefined;
    employeeAvatarId?: string | undefined;
    avatar?: EmployeeAvatarDetail | undefined;
    department?: DepartmentIdNameDto | undefined;
    company?: CompanyIdNameDto | undefined;
    address?: EmployeeAddress | undefined;
}

export class EmployeeAvatarDetail implements IEmployeeAvatarDetail {
    id?: string;
    avatar?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;

    constructor(data?: IEmployeeAvatarDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.avatar = _data["avatar"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EmployeeAvatarDetail {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeAvatarDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["avatar"] = this.avatar;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IEmployeeAvatarDetail {
    id?: string;
    avatar?: string | undefined;
    createdDate?: Date;
    updatedDate?: Date;
}

export class EmployeeAvatar extends Base implements IEmployeeAvatar {
    employeeId?: string;
    employee?: Employee | undefined;
    avatar?: string | undefined;

    constructor(data?: IEmployeeAvatar) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.employeeId = _data["employeeId"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.avatar = _data["avatar"];
        }
    }

    static override fromJS(data: any): EmployeeAvatar {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeAvatar();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeId"] = this.employeeId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["avatar"] = this.avatar;
        super.toJSON(data);
        return data;
    }
}

export interface IEmployeeAvatar extends IBase {
    employeeId?: string;
    employee?: Employee | undefined;
    avatar?: string | undefined;
}

export class IdentityUserOfGuid implements IIdentityUserOfGuid {
    id?: string;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;

    constructor(data?: IIdentityUserOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.email = _data["email"];
            this.normalizedEmail = _data["normalizedEmail"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.passwordHash = _data["passwordHash"];
            this.securityStamp = _data["securityStamp"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.accessFailedCount = _data["accessFailedCount"];
        }
    }

    static fromJS(data: any): IdentityUserOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["normalizedUserName"] = this.normalizedUserName;
        data["email"] = this.email;
        data["normalizedEmail"] = this.normalizedEmail;
        data["emailConfirmed"] = this.emailConfirmed;
        data["passwordHash"] = this.passwordHash;
        data["securityStamp"] = this.securityStamp;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        return data;
    }
}

export interface IIdentityUserOfGuid {
    id?: string;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
}

export class ApplicationUser extends IdentityUserOfGuid implements IApplicationUser {
    firstName?: string | undefined;
    lastName?: string | undefined;

    constructor(data?: IApplicationUser) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static override fromJS(data: any): ApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUser();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        super.toJSON(data);
        return data;
    }
}

export interface IApplicationUser extends IIdentityUserOfGuid {
    firstName?: string | undefined;
    lastName?: string | undefined;
}

export class Employee extends ApplicationUser implements IEmployee {
    title?: Title;
    gender?: Gender;
    middleName?: string | undefined;
    workEmailAddress?: string | undefined;
    personalEmailAddress?: string | undefined;
    workPhoneNumber?: string | undefined;
    workMobileNumber?: string | undefined;
    personalMobileNumber?: string | undefined;
    jobTitle?: string | undefined;
    holidayAllowance?: number;
    dateOfBirth?: Date;
    startOfEmployment?: Date;
    endOfEmployment?: Date | undefined;
    addressId?: string;
    passportNumber?: string | undefined;
    nationalInsuranceNumber?: string | undefined;
    departmentId?: string | undefined;
    companyId?: string;
    employeeAvatarId?: string;
    managerId?: string | undefined;
    address?: EmployeeAddress | undefined;
    manager?: Employee | undefined;
    department?: Department | undefined;
    company?: Company | undefined;
    avatar?: EmployeeAvatar | undefined;
    notes?: Note[] | undefined;

    constructor(data?: IEmployee) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"];
            this.gender = _data["gender"];
            this.middleName = _data["middleName"];
            this.workEmailAddress = _data["workEmailAddress"];
            this.personalEmailAddress = _data["personalEmailAddress"];
            this.workPhoneNumber = _data["workPhoneNumber"];
            this.workMobileNumber = _data["workMobileNumber"];
            this.personalMobileNumber = _data["personalMobileNumber"];
            this.jobTitle = _data["jobTitle"];
            this.holidayAllowance = _data["holidayAllowance"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.startOfEmployment = _data["startOfEmployment"] ? new Date(_data["startOfEmployment"].toString()) : <any>undefined;
            this.endOfEmployment = _data["endOfEmployment"] ? new Date(_data["endOfEmployment"].toString()) : <any>undefined;
            this.addressId = _data["addressId"];
            this.passportNumber = _data["passportNumber"];
            this.nationalInsuranceNumber = _data["nationalInsuranceNumber"];
            this.departmentId = _data["departmentId"];
            this.companyId = _data["companyId"];
            this.employeeAvatarId = _data["employeeAvatarId"];
            this.managerId = _data["managerId"];
            this.address = _data["address"] ? EmployeeAddress.fromJS(_data["address"]) : <any>undefined;
            this.manager = _data["manager"] ? Employee.fromJS(_data["manager"]) : <any>undefined;
            this.department = _data["department"] ? Department.fromJS(_data["department"]) : <any>undefined;
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
            this.avatar = _data["avatar"] ? EmployeeAvatar.fromJS(_data["avatar"]) : <any>undefined;
            if (Array.isArray(_data["notes"])) {
                this.notes = [] as any;
                for (let item of _data["notes"])
                    this.notes!.push(Note.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Employee {
        data = typeof data === 'object' ? data : {};
        let result = new Employee();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["gender"] = this.gender;
        data["middleName"] = this.middleName;
        data["workEmailAddress"] = this.workEmailAddress;
        data["personalEmailAddress"] = this.personalEmailAddress;
        data["workPhoneNumber"] = this.workPhoneNumber;
        data["workMobileNumber"] = this.workMobileNumber;
        data["personalMobileNumber"] = this.personalMobileNumber;
        data["jobTitle"] = this.jobTitle;
        data["holidayAllowance"] = this.holidayAllowance;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["startOfEmployment"] = this.startOfEmployment ? this.startOfEmployment.toISOString() : <any>undefined;
        data["endOfEmployment"] = this.endOfEmployment ? this.endOfEmployment.toISOString() : <any>undefined;
        data["addressId"] = this.addressId;
        data["passportNumber"] = this.passportNumber;
        data["nationalInsuranceNumber"] = this.nationalInsuranceNumber;
        data["departmentId"] = this.departmentId;
        data["companyId"] = this.companyId;
        data["employeeAvatarId"] = this.employeeAvatarId;
        data["managerId"] = this.managerId;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["manager"] = this.manager ? this.manager.toJSON() : <any>undefined;
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["avatar"] = this.avatar ? this.avatar.toJSON() : <any>undefined;
        if (Array.isArray(this.notes)) {
            data["notes"] = [];
            for (let item of this.notes)
                data["notes"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IEmployee extends IApplicationUser {
    title?: Title;
    gender?: Gender;
    middleName?: string | undefined;
    workEmailAddress?: string | undefined;
    personalEmailAddress?: string | undefined;
    workPhoneNumber?: string | undefined;
    workMobileNumber?: string | undefined;
    personalMobileNumber?: string | undefined;
    jobTitle?: string | undefined;
    holidayAllowance?: number;
    dateOfBirth?: Date;
    startOfEmployment?: Date;
    endOfEmployment?: Date | undefined;
    addressId?: string;
    passportNumber?: string | undefined;
    nationalInsuranceNumber?: string | undefined;
    departmentId?: string | undefined;
    companyId?: string;
    employeeAvatarId?: string;
    managerId?: string | undefined;
    address?: EmployeeAddress | undefined;
    manager?: Employee | undefined;
    department?: Department | undefined;
    company?: Company | undefined;
    avatar?: EmployeeAvatar | undefined;
    notes?: Note[] | undefined;
}

export enum Title {
    Mr = 0,
    Mrs = 1,
    Miss = 2,
    Ms = 3,
    Mx = 4,
    Sir = 5,
    Dr = 6,
    Cllr = 7,
    Lady = 8,
    Lord = 9,
}

export enum Gender {
    Male = 0,
    Female = 1,
    Other = 2,
}

export class Department extends Base implements IDepartment {
    name?: string | undefined;
    companyId?: string;
    company?: Company | undefined;

    constructor(data?: IDepartment) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): Department {
        data = typeof data === 'object' ? data : {};
        let result = new Department();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IDepartment extends IBase {
    name?: string | undefined;
    companyId?: string;
    company?: Company | undefined;
}

export class Company extends Base implements ICompany {
    name?: string | undefined;
    logo?: string | undefined;
    address?: CompanyAddress | undefined;
    employees?: Employee[] | undefined;
    companyConfig?: CompanyConfig | undefined;

    constructor(data?: ICompany) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.logo = _data["logo"];
            this.address = _data["address"] ? CompanyAddress.fromJS(_data["address"]) : <any>undefined;
            if (Array.isArray(_data["employees"])) {
                this.employees = [] as any;
                for (let item of _data["employees"])
                    this.employees!.push(Employee.fromJS(item));
            }
            this.companyConfig = _data["companyConfig"] ? CompanyConfig.fromJS(_data["companyConfig"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): Company {
        data = typeof data === 'object' ? data : {};
        let result = new Company();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["logo"] = this.logo;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        if (Array.isArray(this.employees)) {
            data["employees"] = [];
            for (let item of this.employees)
                data["employees"].push(item.toJSON());
        }
        data["companyConfig"] = this.companyConfig ? this.companyConfig.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ICompany extends IBase {
    name?: string | undefined;
    logo?: string | undefined;
    address?: CompanyAddress | undefined;
    employees?: Employee[] | undefined;
    companyConfig?: CompanyConfig | undefined;
}

export class CompanyConfig extends Base implements ICompanyConfig {
    companyId?: string;
    company?: Company | undefined;
    gdprRetentionPeriodInYears?: number;

    constructor(data?: ICompanyConfig) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
            this.gdprRetentionPeriodInYears = _data["gdprRetentionPeriodInYears"];
        }
    }

    static override fromJS(data: any): CompanyConfig {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyConfig();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["gdprRetentionPeriodInYears"] = this.gdprRetentionPeriodInYears;
        super.toJSON(data);
        return data;
    }
}

export interface ICompanyConfig extends IBase {
    companyId?: string;
    company?: Company | undefined;
    gdprRetentionPeriodInYears?: number;
}

export class Note extends Base implements INote {
    employeeId?: string;
    title?: string | undefined;
    content?: string | undefined;
    noteType?: NoteType;

    constructor(data?: INote) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.employeeId = _data["employeeId"];
            this.title = _data["title"];
            this.content = _data["content"];
            this.noteType = _data["noteType"];
        }
    }

    static override fromJS(data: any): Note {
        data = typeof data === 'object' ? data : {};
        let result = new Note();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeId"] = this.employeeId;
        data["title"] = this.title;
        data["content"] = this.content;
        data["noteType"] = this.noteType;
        super.toJSON(data);
        return data;
    }
}

export interface INote extends IBase {
    employeeId?: string;
    title?: string | undefined;
    content?: string | undefined;
    noteType?: NoteType;
}

export enum NoteType {
    General = 0,
    Leaving = 1,
    Appraisal = 2,
}

export class EmployeeCreateDto implements IEmployeeCreateDto {
    username?: string | undefined;
    title?: string | undefined;
    gender?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    workEmailAddress!: string;
    personalEmailAddress?: string | undefined;
    workPhoneNumber?: string | undefined;
    workMobileNumber?: string | undefined;
    personalMobileNumber?: string | undefined;
    holidayAllowance?: number;
    dateOfBirth?: Date;
    startOfEmployment!: Date;
    address?: AddressCreateDto | undefined;
    departmentId?: string | undefined;
    companyId!: string;
    passportNumber?: string | undefined;
    nationalInsuranceNumber?: string | undefined;
    managerId?: string | undefined;
    jobTitle?: string | undefined;

    constructor(data?: IEmployeeCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.title = _data["title"];
            this.gender = _data["gender"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.workEmailAddress = _data["workEmailAddress"];
            this.personalEmailAddress = _data["personalEmailAddress"];
            this.workPhoneNumber = _data["workPhoneNumber"];
            this.workMobileNumber = _data["workMobileNumber"];
            this.personalMobileNumber = _data["personalMobileNumber"];
            this.holidayAllowance = _data["holidayAllowance"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.startOfEmployment = _data["startOfEmployment"] ? new Date(_data["startOfEmployment"].toString()) : <any>undefined;
            this.address = _data["address"] ? AddressCreateDto.fromJS(_data["address"]) : <any>undefined;
            this.departmentId = _data["departmentId"];
            this.companyId = _data["companyId"];
            this.passportNumber = _data["passportNumber"];
            this.nationalInsuranceNumber = _data["nationalInsuranceNumber"];
            this.managerId = _data["managerId"];
            this.jobTitle = _data["jobTitle"];
        }
    }

    static fromJS(data: any): EmployeeCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["title"] = this.title;
        data["gender"] = this.gender;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["workEmailAddress"] = this.workEmailAddress;
        data["personalEmailAddress"] = this.personalEmailAddress;
        data["workPhoneNumber"] = this.workPhoneNumber;
        data["workMobileNumber"] = this.workMobileNumber;
        data["personalMobileNumber"] = this.personalMobileNumber;
        data["holidayAllowance"] = this.holidayAllowance;
        data["dateOfBirth"] = this.dateOfBirth ? formatDate(this.dateOfBirth) : <any>undefined;
        data["startOfEmployment"] = this.startOfEmployment ? formatDate(this.startOfEmployment) : <any>undefined;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["departmentId"] = this.departmentId;
        data["companyId"] = this.companyId;
        data["passportNumber"] = this.passportNumber;
        data["nationalInsuranceNumber"] = this.nationalInsuranceNumber;
        data["managerId"] = this.managerId;
        data["jobTitle"] = this.jobTitle;
        return data;
    }
}

export interface IEmployeeCreateDto {
    username?: string | undefined;
    title?: string | undefined;
    gender?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    workEmailAddress: string;
    personalEmailAddress?: string | undefined;
    workPhoneNumber?: string | undefined;
    workMobileNumber?: string | undefined;
    personalMobileNumber?: string | undefined;
    holidayAllowance?: number;
    dateOfBirth?: Date;
    startOfEmployment: Date;
    address?: AddressCreateDto | undefined;
    departmentId?: string | undefined;
    companyId: string;
    passportNumber?: string | undefined;
    nationalInsuranceNumber?: string | undefined;
    managerId?: string | undefined;
    jobTitle?: string | undefined;
}

export class LeaveRequest extends Base implements ILeaveRequest {
    employeeId?: string;
    approvedById?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    startDateFirstHalf?: boolean;
    startDateSecondHalf?: boolean;
    endDateFirstHalf?: boolean;
    endDateSecondHalf?: boolean;
    approved?: boolean;
    comments?: string | undefined;
    leaveType?: LeaveType;

    constructor(data?: ILeaveRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.employeeId = _data["employeeId"];
            this.approvedById = _data["approvedById"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.startDateFirstHalf = _data["startDateFirstHalf"];
            this.startDateSecondHalf = _data["startDateSecondHalf"];
            this.endDateFirstHalf = _data["endDateFirstHalf"];
            this.endDateSecondHalf = _data["endDateSecondHalf"];
            this.approved = _data["approved"];
            this.comments = _data["comments"];
            this.leaveType = _data["leaveType"];
        }
    }

    static override fromJS(data: any): LeaveRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeId"] = this.employeeId;
        data["approvedById"] = this.approvedById;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["startDateFirstHalf"] = this.startDateFirstHalf;
        data["startDateSecondHalf"] = this.startDateSecondHalf;
        data["endDateFirstHalf"] = this.endDateFirstHalf;
        data["endDateSecondHalf"] = this.endDateSecondHalf;
        data["approved"] = this.approved;
        data["comments"] = this.comments;
        data["leaveType"] = this.leaveType;
        super.toJSON(data);
        return data;
    }
}

export interface ILeaveRequest extends IBase {
    employeeId?: string;
    approvedById?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    startDateFirstHalf?: boolean;
    startDateSecondHalf?: boolean;
    endDateFirstHalf?: boolean;
    endDateSecondHalf?: boolean;
    approved?: boolean;
    comments?: string | undefined;
    leaveType?: LeaveType;
}

export enum LeaveType {
    Holiday = 0,
    Sickness = 1,
}

export class CreateLeaveRequest implements ICreateLeaveRequest {
    employeeId?: string;
    startDate?: Date;
    endDate?: Date;
    startDateFirstHalf?: boolean;
    startDateSecondHalf?: boolean;
    endDateFirstHalf?: boolean;
    endDateSecondHalf?: boolean;
    leaveType?: LeaveType;
    comments?: string | undefined;

    constructor(data?: ICreateLeaveRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.employeeId = _data["employeeId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.startDateFirstHalf = _data["startDateFirstHalf"];
            this.startDateSecondHalf = _data["startDateSecondHalf"];
            this.endDateFirstHalf = _data["endDateFirstHalf"];
            this.endDateSecondHalf = _data["endDateSecondHalf"];
            this.leaveType = _data["leaveType"];
            this.comments = _data["comments"];
        }
    }

    static fromJS(data: any): CreateLeaveRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLeaveRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeId"] = this.employeeId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["startDateFirstHalf"] = this.startDateFirstHalf;
        data["startDateSecondHalf"] = this.startDateSecondHalf;
        data["endDateFirstHalf"] = this.endDateFirstHalf;
        data["endDateSecondHalf"] = this.endDateSecondHalf;
        data["leaveType"] = this.leaveType;
        data["comments"] = this.comments;
        return data;
    }
}

export interface ICreateLeaveRequest {
    employeeId?: string;
    startDate?: Date;
    endDate?: Date;
    startDateFirstHalf?: boolean;
    startDateSecondHalf?: boolean;
    endDateFirstHalf?: boolean;
    endDateSecondHalf?: boolean;
    leaveType?: LeaveType;
    comments?: string | undefined;
}

export class NoteDetailDto implements INoteDetailDto {
    id?: string;
    createdDate?: Date;
    updatedDate?: Date;
    employeeId?: string;
    title?: string | undefined;
    content?: string | undefined;
    noteType?: NoteType;

    constructor(data?: INoteDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.title = _data["title"];
            this.content = _data["content"];
            this.noteType = _data["noteType"];
        }
    }

    static fromJS(data: any): NoteDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new NoteDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["title"] = this.title;
        data["content"] = this.content;
        data["noteType"] = this.noteType;
        return data;
    }
}

export interface INoteDetailDto {
    id?: string;
    createdDate?: Date;
    updatedDate?: Date;
    employeeId?: string;
    title?: string | undefined;
    content?: string | undefined;
    noteType?: NoteType;
}

export class NoteCreateDto implements INoteCreateDto {
    title?: string | undefined;
    content?: string | undefined;
    noteType?: NoteType;

    constructor(data?: INoteCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.content = _data["content"];
            this.noteType = _data["noteType"];
        }
    }

    static fromJS(data: any): NoteCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new NoteCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["content"] = this.content;
        data["noteType"] = this.noteType;
        return data;
    }
}

export interface INoteCreateDto {
    title?: string | undefined;
    content?: string | undefined;
    noteType?: NoteType;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}